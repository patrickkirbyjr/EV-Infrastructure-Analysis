---
title: "Quick Coverage Map Creator with Population Densities"
output: html_notebook
---
goal: turn this pipeline into a function for easy analysis of multiple states

ADD POPULATION HEATMAP

import data

```{r}
ev_locations <- read_csv("data/ev_station_locations.csv") |>
    filter(!is.na(latitude), !is.na(longitude))

ev_locations
```

```{r}
library(tidyverse)
library(sf)
library(tidycensus)
library(osmdata)
library(ggplot2)
library(rnaturalearth)
library(rnaturalearthdata)
library(scales)

analyze_ev_coverage <- function(state_abbr, buffer) {
  
  # filter EV locations to selected state
  ev_locations_state <- ev_locations |> filter(state == state_abbr)
  coords <- ev_locations_state |> select(longitude, latitude) |> as.data.frame()
  stations_sf <- st_as_sf(coords, 
                          coords = c("longitude", "latitude"), 
                          crs = 4326
                          ) |> st_make_valid()
  
  # get population data for counties in selected state
  population <- get_acs(geography = "county",
                      variables = "B01003_001",
                      year = 2022,
                      geometry = TRUE,
                      state = state_abbr)
  population <- st_transform(population, st_crs(stations_sf)) |> st_make_valid()
  
  population <- population |>
  mutate(area_mi2 = as.numeric(st_area(geometry)) / 2.59e6,
         pop_density = estimate / area_mi2)
  
  #create bbox
  bbox <- st_bbox(population)
  
  # create buffers (enter in miles and it will convert to meters)
  buffers <- st_buffer(stations_sf, dist = buffer * 1609)
  coverage_area <-st_make_valid(st_union(buffers))
  
  # determine uncovered areas
  uncovered <- st_make_valid(st_difference(st_union(st_geometry(population)), coverage_area))
  
  # plot coverage map
  ggplot() +
    geom_sf(data = population, aes(fill = pop_density), color = "white", size = 0.2) +
    scale_fill_viridis_c(option = "viridis", 
                         trans = "log",
                         limits = c(10, 10000),
                         breaks = c(10, 100, 1000, 10000),
                         labels = label_comma(accuracy = 1),
                         name = bquote("Population Density (people/mi"^2*")")) +
    geom_sf(data = st_boundary(coverage_area), color = "magenta", alpha = 1, size = 1.5) +
    coord_sf(xlim = c(bbox["xmin"], bbox["xmax"]), ylim = c(bbox["ymin"], bbox["ymax"]), expand = FALSE) +
    ggtitle(paste0(state_abbr, " EV Station Coverage with Population Density (", buffer, " Mile Convenience)")) +
    labs(subtitle = paste("Areas inside magenta boundaries are within", buffer, "miles of an EV station"))
  
  # save to file
  ggsave(paste0("outputs/coverage_maps_with_population/ev_station_coverage_with_population_", state_abbr, "_", buffer, "mi.png"))
}
```

test function

```{r}
analyze_ev_coverage("TX", 10)
analyze_ev_coverage("FL", 10)
analyze_ev_coverage("NJ", 10)
analyze_ev_coverage("IL", 10)
analyze_ev_coverage("NV", 10)
analyze_ev_coverage("PA", 10)
```

excellent!
now, let's use it to check out the top underbuilt states + PA

```{r}
top_underbuilt_states <- c("TX", "FL", "NJ", "IL", "NV", "PA")
buffers <- c(5, 10, 15, 20)

for (state in top_underbuilt_states) {
  for (buffer in buffers) {
    cat("Creating coverage map for", state, "with buffer", buffer, "miles...\n")
    plot_obj <- analyze_ev_coverage(state, buffer)
  }
}
```